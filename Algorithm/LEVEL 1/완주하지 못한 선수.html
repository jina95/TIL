<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>코딩테스트 알고리즘 연습 문제</title>
</head>
<body>
    <h1>완주하지 못한 선수</h1>
    <em>문제 설명 </em>
    <p>
        수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.
        
        마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를
        작성해주세요.
    </p>
    <h3>제한 조건</h3>
    <ul>
        <li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li>
        <li>completion의 길이는 participant의 길이보다 1 작습니다.</li>
        <li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li>
        <li>참가자 중에는 동명이인이 있을 수 있습니다.</li>
    </ul>
<script>
    // 예를 들어 확인할 숫자 || 글자
    let participant = ["mislav", "stanko", "mislav", "ana"]
    let completion = ["stanko", "ana", "mislav"]
    
    console.log(solution(participant, completion));
    
    // 처음으로 풀었던 방식
    function solution(participant, completion) {
        
        let newArray = participant.concat(completion).sort()
        // 배열을 합친 뒤 정렬
        let answer = ""
        for (let i = 0; i <= newArray.length; i++) {
            if(newArray[i] == newArray[i + 1]) {
                newArray.splice(newArray[i],1)
            }
            else return answer = newArray[i]
        }
        return newArray.toString()

        // 테스트는 통과하는데 효율성테스트에서 떨어진다.

        let newArray = participant.concat(completion).sort()
        for (let i = 0; i <= newArray.length; i++) {
            if (newArray[i] == newArray[i + 1]) {
                newArray.splice(newArray[i], 1)
            }
            else return newArray[i].toString()
        }

        // 코드를 정리해봤지만 효율성에서는 역시나 떨어진다...

        let newParti = participant.sort()
        let newCom = completion.sort()

        for (let i = 0; i < participant.length; i++) {
            if (newParti[i] !== newCom[i]) return newParti[i]
        }
        // 테스트 통과!!!!!!!!!!!!!!

    }


    // 다른사람의 풀이

    function solution(participant, completion) {
        var dic = completion.reduce((obj, t) => (obj[t] = obj[t] ? obj[t] + 1 : 1, obj), {});
        return participant.find(t => {
            if (dic[t])
                dic[t] = dic[t] - 1;
            else
                return true;
        });
    }

    // reduce() 메서드는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다
    // find() 메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환
    // 이해가 잘 되지않는다...
    
</script>
</body>
</html>