# 프론트엔드 개발환경의 이해와 실습 (webpack, babel, eslint..) 💻 

## 1️⃣
### 🖥 NPM
#### 1 - 1. 프로젝트 생성
- **프론트엔드 개발에 Node.js가 필요한 이유**
- 1. 최신 스펙으로 개발할 수 있다.
- 2. 빌드 자동화
- 3. 개발환경 커스터마이징

- 노드 설치
- 노드로 서버를 운영 : 왼쪽의 LTS버전
- 개발환경을구축 : 오른쪽의 최신버전

- 터미널에 $node 입력 -> 노드 터미널 도구 열림 : REPL ( 자바스크립트 코드를 입력하고 즉시 확인할 수 있는 프로그램 ) -> 종료시 $ .exit

- [node.js 업데이트 참고 블로그](https://velopert.com/1351) 

- $ npm init ( 프로젝트 생성 명령어 )
- package name -> 프로젝트 이름 / 쭉 엔터 치고 나면 package.json 이 생성된 것을 볼 수 있다.
- package.json / scripts : 프로젝트를 자동화 할 수 있는 shell script 를 입력할 수 있는 부분

- **프로젝트 명령어**

<img src="https://github.com/jina95/TIL/blob/master/images/Webpack/webpack_test%EB%AA%85%EB%A0%B9%EC%96%B4.png" width="70%">

- Error: no test specified -> 이러한 문자열을 echo 명령어로 출력 , 에러코드 1번을 반환하는 shell script, 일종의 샘플 스크립트
- 스크립트 실행 -> $ npm test -> 등록한 shell script가 실행!
- 기본적 제공 커멘드 외에 추가하고 싶다면 ? 

<img src="https://github.com/jina95/TIL/blob/master/images/Webpack/webpack_build%EC%BB%A4%EC%8A%A4%ED%85%80.png" width="70%">

- 커스텀 스크립트를 실행할때는 $ npm run 커멘드이름

<img src="https://github.com/jina95/TIL/blob/master/images/Webpack/webpack_build%EC%BB%A4%EC%8A%A4%ED%85%80_%EA%B2%B0%EA%B3%BC.png" width="70%">

#### 1 - 2. 외부 패키지를 관리하는 방법
- 패키지 설치
- 1. CDN( 컨텐츠 전송 네트워크 ) 방식
- 2. 직접 다운로드 
- 3. npm 을 이용한 방법 / $ npm install 라이브러리 -> package.json 파일에 dependencies 부분이 추가된다.

- **유의적 버전과 버전의 범위**
- [유의적 버전(Sementic Version)](https://semver.org/lang/ko/)
- 주 버전(Major Version): 기존 버전과 호환되지 않게 변경한 경우
- 부 버전(Minor version): 기존 버전과 호환되면서 기능이 추가된 경우
- 수 버전(Patch version): 기존 버전과 호환되면서 버그를 수정한 경우
> 위의 내용은 https://jeonghwan-kim.github.io/series/2019/12/09/frontend-dev-env-npm.html 블로그내용 복붙

```json
"dependencies": {
    "react": "^16.13.1"
    }
```

- 위와 같은 코드에서는 16 - 주버전 / 13 - 부버전 / 1 - 수버전
- 이처럼 버전 번호를 관리하는 방법을 유의적버전 / node.js 는 유의적 버전 규칙을 따른다

- **버전의 범위**
- 단순한버전은 숫자만 입력 / 특정버전보다 낮거나 높을때는 >, >=, <, <=
- 틸드(~)와 캐럿(^)
- 틸드 : 마이너 버전이 명시되어있다면 패치버전을 변경한다. 예를 들어 ~1.2.3 은 1.2.3 부터 1.3.0 미만까지 / 마이너버전이 없으면 마이너버전을 갱신 / ~0 표기는 0.0.0 부터 1.0.0 미만까지를 포함
- 캐럿 : 정식버전일경우에 마이너와 패치버전을 변경. 예를들어 ^1.2.3 이면 1.2.3 부터 2.0.0 미만까지 / 하지만 정식버전 미만인 0.x 버전은 패치만 갱신 / ^0 표시는 0.0.0 부터 0.1.0 미만까지를 포함 

### 🖥 웹팩(Webpack) - 기본편
#### 2 - 1. 웹팩이 필요한 이유와 기본 동작

```javascript
// math.js
function sum(a, b){
    return a + b;
}

// app.js
console.log(sum(1, 2));
```

- 위와 같은 방식은 전역스코프가 오염된다. 
- sum은 math 안에서만 유효한것이 아닌 어느곳에서도 다 접근할 수 있다
- 따라서 전역스코프 오염 -> 예측할 수없게 됨 -> 런타임에러

- **즉시실행함수** - 스코프사용 ( 안에서만 사용가능 (외부에서는 접근하지 못한다)-> 전역스코프오염 x )

```javascript
// math.js
var math = math || {};

(function(){
  function sum(a, b){
      return a + b;
  }
  math.sum = sum;
})()

// app.js
console.log(math.sum(1, 2));
```

- 이러한 방식으로 js 모듈을 구현하는 대표적인 명세가 AMD 와 CommonJS
> CommonJS는 자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표다. exports 키워드로 모듈을 만들고 require() 함수로 불러 들이는 방식이다. 대표적으로 서버 사이드 플래폼인 Node.js에서 이를 사용한다.

> AMD(Asynchronous Module Definition)는 비동기로 로딩되는 환경에서 모듈을 사용하는 것이 목표다. 주로 브라우져 환경이다.

- [김정환님 블로그](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html)

- commonJs + AMD -> UMD
- 이후 ES2015 표준모듈시스템

```javascript
// math.js
export function sum(a, b){
    return a + b
}

// app.js
import * as math from './math'
console.log(math.sum(1, 2));
```

- 모든 브라우저에서 모듈시스템을 지원하지 않기때문에 아래와 같이 추가해준다.

```javascript
// index.html
<script type="module" src="app.js"></script>
```

> html 파일을 바로 열고싶을때 $ open index.html(파일이름)
> 간단하게 서버를 킬때 $ npm lite-server

#### 2 - 2. 엔트리/아웃풋 실습
- 모듈로 연결된 여러개의 자바스크립트파일을 하나로 합쳐주는 역할 -> 웹팩
- 이렇게 하나로 합쳐진 파일 -> 번들 ( 웹팩이 번들을 만드는 번들러 역할을 하는것 / 웹팩 = 번들러)
- 웹팩(번들작업), 웹팩 cli(웹팩을 터미널명령으로 사용할 수 있는) 설치 / $ npm install -D webpack webpack-cli
- 위에서 설치시 -D 옵션을 주었기때문에 package.json devDependencies 에서 확인 가능하다.
- devDependencies : 개발용 패키지 
- 설치후 node_modules > .bin > webpack, webpack-cli 설치되어있음을 확인할 수 있다.

> $ node_modules/.bin/webpack --help
- **webpack 필수요소** 
- 1️⃣ --mode : "development", "production", "none" / 개발환경이냐 운영환경이냐에 따라 설정 
- 개발용 정보 추가 -> development / 운영에 배포하기위한 최적화 설정 -> production
- 2️⃣ --entry : 모듈의 시작점 / 엔트리를 지정해줘야함 ( 필수 )
- 엔트리를 통해서 웹팩이 모든 모듈을 하나로 합치고 그 결과를 저장하는경로를 -> output

<img src="https://github.com/jina95/TIL/blob/master/images/Webpack/webpack-%EC%97%94%ED%8A%B8%EB%A6%AC%ED%8F%AC%EC%9D%B8%ED%8A%B8.png" width="70%">

- 3️⃣ --output, -o : 결과 저장하는 경로 설정 옵션 

<img src="https://github.com/jina95/TIL/blob/master/images/Webpack/webpack-%EB%B2%88%EB%93%A4%EB%A7%81%EA%B2%B0%EA%B3%BC.png" width="70%">

- 세가지 옵션으로 우리 코드를 번들링 해보자.
- $ node_modules/.bin/webpack --mode development --entry ./src/app.js --output dist/main.js
- 위의 사진같은 결과를 얻을 수 있다.
- 매번 명령어를 입력할때마다 터미널을 긴 옵션을 줄 수 없기때문에 webpack 설정 파일을 만든다.
- config 파일 명: webpack.config.js or webpackfile.js

```javascript
// webpack.config.js
const path = require('path') // node 모듈

module.exports = {
  // module.exports -> node 의 모듈 시스템
  mode: "development",
  entry: {
    main: "./src/app.js",
    // 경로 뿐만 아니라 main 이라는 key 값도 설정
  },
  output: {
    path: path.resolve("./dist"),
    // path 는 output 디렉토리명을 입력, 절대경로 입력
    filename: "[name].js",
    // entry에서 설정한 key값으로 설정( ex main)
    // entry 가 여러개일수도있기때문에, 동적으로 만들어내기위해 [name] 으로 설정
  },
};
```

- npm -> 프로젝트를 관리하는, 스크립트를 자동화 해주는 기능
- 웹팩으로 번들링 해주는 과정을 npm 스크립트의 등록 -> package.json scripts build : 'webpack'
- 이렇게 적어주면 npm은 현재 프로젝트에 있는 node modules 에서 웹팩을 찾는다.
- $ npm run build

<img src="https://github.com/jina95/TIL/blob/master/images/Webpack/webpack-npmrunbuild.png" width="70%">

- entry 는 자바스크립트 모듈이 의존관계가 있는데 그 시작점! 
- webpack 은 그 시작점을 기준으로 모든 모듈을 찾아서 하나의 파일로 번들 -> 결과를 output 에 설정.  

#### 2 - 3. 엔트리와 아웃풋(실습)
#### 2 - 4. 엔트리와 아웃풋(풀이)
- 1. package.json 파일이 없는 상태 -> $ npm init -y (-y:기본값을 다 사용)
- 2. webpack 설치 -> $ npm install webpack webpack-cli
- 3. webpack 명령어 추가 -> package.json scritps build:'webpack' 추가
- 4. webpack.config.js 생성 -> mode, entry, output !!
- 5. index.html 에 빌드한 파일 넣어주기 -> <script src="./dist/main.js"></script>

#### 2 - 5. 로더
- 😶**로더의 역할**
- 웹팩은 js 파일 뿐만아니라 모든 파일을 모듈로 바라본다. 그렇기때문에 import 구문을 사용하면 js 코드 안으로 가져올수 있다.
- 이것이 가능한 이유는 웹팩에 로더가 있기 때문 ( 웹팩에서 로더가 하는일 : 모든 파일을 자바스크립트에 모듈처럼 만들어 준다. )

- 😶**커스텀 로더 만들기**
- 로더는 함수형태로 작성하고, webpack.config.js 에 module 객체에 rules 라는 배열에 추가할 수 있다.

```javascript
// my-webpack-loader.js
module.exports = function myWebpackLoader(content){
    // 로더는 함수형태로 작성한다.
    console.log('myWebpackLoader 작동함');
    return content;
}

// webpack.config.js
const path = require('path')

module.exports = {
    mode: "development",
    entry: {
        main: "./src/app.js"
    },
    output: {
        path: path.resolve('./dist'),
        filename: "[name].js"
    },
    module: {
        rules: [
            {
                test: /\.js/$,
                // test : 로더가 처리해야할 파일의 패턴 (정규표현식)
                // js로 끝나는 모든 파일
                use: [
                    path.resolve('./my-webpack-loader.js')
                ]
                // use : 사용할 로더 명시
                // 모든 자바스크립트 코드에 대해서 my-webpack-loader 가 실행되게끔 하는 설정
            }
        ]
    }
}
```

#### 2 - 6. 자주 사용하는 로더
- 😶**css-loader**
- css 파일을 위한 로더 / js 에서 css 파일을 모듈로 불러올 수 있다.
- $ npm install css-loader

```javascript
    test: /\.css$/,
    use: [
        'css-loader'
    ]
```

- 웹팩은 css 파일을 만나면, css-loader 를 동작하게 된다. -> css-loader 가 css 파일을 처리하게 한다.
- 하지만 아직 js 안에 css 가 있기만 해서 작동하지는 않는다 ( html->css 불러오거나 / 인라인스크립트여야 css 가 읽힌다.)
- $ npm install style-loader

```javascript
    test: /\.css$/,
    use: [
        'style-loader',
        'css-loader'
    ]
```

- 스타일로더 : 자바스크립트로 변경된 스타일코드를 html에 넣어준다. -> webpack.config.js 에 추가해준다.
- 로더는 한파일에서 여러개 실행되는데, use 순서는 뒤에서 앞으로 !
<br>

- 로더는 css 뿐만 아니라, import 구문을 이용해서 이미지도 받아올수 있다.
- $ npm install file-loader (이미지 처리)

```javascript
    test: /\.png$/,
    use: [
        'file-loader'
    ]
```

> webpack 은 빌드 할때마다 유니크한 값을 생성 -> 해쉬값
> 캐쉬갱신을 위해 / 정적파일의 경우 브라우저에서 캐쉬 흔함
> js, img, css, font 등 성능을 위해 캐쉬 -> 파일내용이 달라지고 이름이 같으면 이전의 캐쉬로 저장했던 내용을 브라우저가 사용 -> 이를 예방하는 방법중 하나가 이름을 변경

```javascript
{
    test: /\.(png|jpg|gif|svg)$/,
    loader: 'file-loader',
    options: {
        publicPath: './dist/',
        name:'[name].[ext]?[hash]'
    }
    // publicPath : 파일로드가 처리하는 파일을 모듈로 사용했을때 경로앞에 추가되는 문자열
    // 우리는 output 을 dist로 설정했기때문에 여기서도 dist
    // 파일을 호출할때 앞에 dist 를 붙이고 호출한다.
    // name : 파일로더가 파일아웃풋에 복사할때 사용하는 파일이름
    // 원본파일명 = [name], 확장자명 = [ext], 
}
```

- 위와같이 추가, 변경해주면 img 를 잘 받아온다.

- 😶**url-loader**
- 이미지갯수가 많은, 작은파일을 base64로 인코딩해서 js 문자열로 변환하는 로더
- [data URI scheme](https://en.wikipedia.org/wiki/Data_URI_scheme)
- $ npm install url-loader

```javascript
// app.js
import './app.css';
import nyancat from './nyancat.jpg'

document.addEventListener('DOMContentLoaded', ()=>{
    document.body.innerHTML = `
        <img src="${nyancat}" />
    `
})
// 돔이 만들어 졌을때 이미지태그를 추가

// webpack.config.js
 {
    test: /\.(png|jpg|gif|svg)$/,
    loader: 'url-loader',
    options: {
        publicPath: './dist/',
        name:'[name].[ext]?[hash]',
        limit: 20000, //20kb
    }
    // limit : 파일 용량 셋팅, 20kb 미만의 파일은 url-loader 로 base64로 변환
    // limit 이상일때는 file-loader 실행
    // limit 미만은 js 문자열로 변환 / 그 이상은 파일로 복사
}
```

#### 2 - 7. 로더(실습)

```javascript
"scripts": {
    "build": "webpack --progress"
},
```

- --progress : 빌드 상태를 커멘드라인에 표시

#### 2 - 8. 로더(풀이)
- 1. css-loader, style-loader 설치 $ npm install css-loader style-loader 
- 2. webpack.config.js module 등록 
- 3. app.js 에서 main.css 를 받아올수있게된다.
- 4. file-loader 를 통해 위와 같이 img 를 받아올수있게 한다. (이때는 loader, options 필요)
- 5. 작은 파일은 url-loader를 이용한다.

>$ rm -rf dist : dist 폴더 삭제





